<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Elevation Plan Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: sans-serif; }
        #canvas-container { width: 100%; height: 70vh; background: white; position: relative; border-bottom: 2px solid #e5e7eb; }
        canvas { display: block; width: 100% !important; height: 100% !important; }
        .controls { padding: 20px; max-width: 1200px; margin: 0 auto; display: flex; gap: 20px; justify-content: center; align-items: center; flex-wrap: wrap; }
        .log-container { background: #111827; color: #10b981; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 11px; height: 100px; overflow-y: auto; width: 100%; max-width: 1200px; margin: 10px auto; border: 1px solid #374151; }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="log" class="log-container">
    > Initializing architectural engine...
</div>

<div class="controls">
    <button id="btn-sample" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-xl transition shadow-lg transform active:scale-95">
        Sample New Building
    </button>
    <button id="btn-save" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-8 rounded-xl transition shadow-lg transform active:scale-95 flex items-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
        </svg>
        Save PNG + JSON Pair
    </button>
</div>

<script>
    let scene, camera, renderer, buildingGroup;
    let windowObjects = [];
    const container = document.getElementById('canvas-container');
    const logEl = document.getElementById('log');

    function log(msg) {
        const entry = document.createElement('div');
        entry.innerHTML = `> ${msg}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const aspect = container.clientWidth / container.clientHeight;
        const d = 12;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(0, 5, 50);
        camera.lookAt(0, 5, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        generateBuilding();
        animate();
    }

    function clearScene() {
        if (buildingGroup) scene.remove(buildingGroup);
        buildingGroup = new THREE.Group();
        scene.add(buildingGroup);
        windowObjects = [];
    }

    function createBoxWithOutline(w, h, zPos = 0, color = 0xffffff, outlineColor = 0x999999, textureType = 'none') {
        const group = new THREE.Group();
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ color: color }));
        group.add(mesh);

        if (textureType !== 'none') {
            const patternMat = new THREE.LineBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.8 });
            if (textureType === 'siding') {
                for (let y = -h/2 + 0.3; y < h/2; y += 0.4) {
                    const pts = [new THREE.Vector3(-w/2, y, 0.005), new THREE.Vector3(w/2, y, 0.005)];
                    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), patternMat));
                }
            } else if (textureType === 'blocks') {
                for (let y = -h/2 + 0.8; y < h/2; y += 0.8) {
                    const pts = [new THREE.Vector3(-w/2, y, 0.005), new THREE.Vector3(w/2, y, 0.005)];
                    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), patternMat));
                }
                for (let x = -w/2 + 1; x < w/2; x += 1.5) {
                    const pts = [new THREE.Vector3(x, -h/2, 0.005), new THREE.Vector3(x, h/2, 0.005)];
                    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), patternMat));
                }
            }
        }

        const edges = new THREE.EdgesGeometry(new THREE.PlaneGeometry(w, h));
        const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: outlineColor }));
        outline.position.z = 0.01;
        group.add(outline);

        group.position.z = zPos;
        return group;
    }

    function createWindow(x, y, w, h, type, details) {
        let geo;
        if (type === 'circle') {
            geo = new THREE.CircleGeometry(w/2, 32);
        } else if (type === 'arch') {
            const shape = new THREE.Shape();
            shape.moveTo(-w/2, -h/2);
            shape.lineTo(w/2, -h/2);
            shape.lineTo(w/2, h/4);
            shape.absarc(0, h/4, w/2, 0, Math.PI, false);
            shape.lineTo(-w/2, -h/2);
            geo = new THREE.ShapeGeometry(shape);
        } else {
            geo = new THREE.PlaneGeometry(w, h);
        }

        const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
        mesh.position.set(x, y, 0.1);
        buildingGroup.add(mesh);

        const outline = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x888888 }));
        outline.position.set(x, y, 0.11);
        buildingGroup.add(outline);

        if (details && type !== 'circle') {
            const gridMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
            const ptsH = [new THREE.Vector3(x - w/2, y, 0.12), new THREE.Vector3(x + w/2, y, 0.12)];
            const ptsV = [new THREE.Vector3(x, y - h/2, 0.12), new THREE.Vector3(x, y + h/2, 0.12)];
            buildingGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsH), gridMat));
            buildingGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsV), gridMat));
        }

        windowObjects.push(mesh);
    }

    function generateBuilding() {
        clearScene();
        const mainW = 8 + Math.random() * 6;
        const floors = Math.floor(Math.random() * 4) + 1;
        const fH = 3.2;
        const texture = ['none', 'siding', 'blocks'][Math.floor(Math.random() * 3)];

        const mainBody = createBoxWithOutline(mainW, floors * fH, 0, 0xffffff, 0x666666, texture);
        mainBody.position.y = (floors * fH) / 2;
        buildingGroup.add(mainBody);

        if (Math.random() > 0.4) {
            const wingW = 4 + Math.random() * 3;
            const wingFloors = Math.max(1, floors - 1);
            const wing = createBoxWithOutline(wingW, wingFloors * fH, -0.1, 0xffffff, 0x666666, texture);
            wing.position.set(-mainW/2 - wingW/2, (wingFloors * fH) / 2, 0);
            buildingGroup.add(wing);
            addWindowsToSection(-mainW/2 - wingW/2, wingFloors, wingW, fH, true);
        }

        addWindowsToSection(0, floors, mainW, fH, false, true);
        log(`Generated: ${floors} floors, ${texture} style.`);
    }

    function addWindowsToSection(centerX, floorCount, sectionW, floorH, forceAsym, hasMainDoor = false) {
        const winType = ['square', 'arch', 'circle', 'tall'][Math.floor(Math.random() * 4)];
        const useDetails = Math.random() > 0.4;
        const winScale = 0.5 + Math.random() * 0.4;
        const winW = (winType === 'tall' ? 0.6 : 1.2) * winScale;
        const winH = (winType === 'tall' ? 1.8 : 1.2) * winScale;
        const cols = Math.max(1, Math.floor(sectionW / 2.5));
        const spacing = sectionW / (cols + 1);

        for (let f = 0; f < floorCount; f++) {
            const y = (f * floorH) + (floorH / 2);
            const isGround = (f === 0);
            const skipProb = forceAsym ? 0.3 : 0.05;

            for (let c = 0; c < cols; c++) {
                if (Math.random() < skipProb) continue;
                const x = centerX - (sectionW/2) + (spacing * (c + 1));
                if (isGround && hasMainDoor && c === Math.floor(cols/2)) {
                    const dW = 1.2, dH = 2.2;
                    const door = createBoxWithOutline(dW, dH, 0.1, 0xffffff, 0x777777, 'none');
                    door.position.set(x, dH/2, 0);
                    buildingGroup.add(door);
                } else {
                    createWindow(x, y, winW, winH, winType, useDetails);
                }
            }
        }
    }

    async function savePair() {
        renderer.render(scene, camera);
        const imgData = renderer.domElement.toDataURL("image/png");

        const bboxes = windowObjects.map(obj => {
            const box = new THREE.Box3().setFromObject(obj);
            const min = box.min.clone().project(camera);
            const max = box.max.clone().project(camera);
            return {
                bbox_2d: [
                    Math.round(((min.x + 1) / 2) * 1000),
                    Math.round(((1 - max.y) / 2) * 1000),
                    Math.round(((max.x + 1) / 2) * 1000),
                    Math.round(((1 - min.y) / 2) * 1000)
                ],
                label: "window"
            };
        });

        const timestamp = Math.floor(Date.now() / 1000);
        const baseName = `synthetic_elevation_${timestamp}`;

        // 1. Save Image
        const imgLink = document.createElement('a');
        imgLink.href = imgData;
        imgLink.download = `${baseName}.png`;
        imgLink.click();

        // 2. Save JSON
        const jsonContent = JSON.stringify(bboxes, null, 4);
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const jsonLink = document.createElement('a');
        jsonLink.href = URL.createObjectURL(blob);
        jsonLink.download = `${baseName}.json`;
        jsonLink.click();

        log(`Saved locally: <b>${baseName}</b> .png and .json`);
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        const aspect = container.clientWidth / container.clientHeight;
        const d = 12;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });

    document.getElementById('btn-sample').addEventListener('click', generateBuilding);
    document.getElementById('btn-save').addEventListener('click', savePair);

    init();
</script>

</body>
</html>