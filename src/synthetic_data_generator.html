<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Elevation Plan Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: sans-serif; }
        #canvas-container { width: 100%; height: 75vh; background: white; position: relative; border-bottom: 2px solid #e5e7eb; }
        canvas { display: block; width: 100% !important; height: 100% !important; }
        .controls { padding: 20px; max-width: 1200px; margin: 0 auto; display: flex; gap: 20px; justify-content: center; align-items: center; flex-wrap: wrap; }
        .log-container { background: #1f2937; color: #10b981; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 11px; height: 80px; overflow-y: auto; width: 100%; max-width: 1200px; margin: 0 auto 10px auto; }
        .badge { background: #374151; color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 10px; margin-left: 5px; }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="log" class="log-container">
    > Initializing architectural engine...
</div>

<div class="controls">
    <button id="btn-sample" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-xl transition shadow-lg transform active:scale-95">
        Sample Complex Building
    </button>
    <button id="btn-export" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-8 rounded-xl transition shadow-lg transform active:scale-95">
        Export PNG + JSON
    </button>
</div>

<script>
    let scene, camera, renderer, buildingGroup;
    let windowObjects = [];
    const container = document.getElementById('canvas-container');
    const logEl = document.getElementById('log');

    function log(msg) {
        const entry = document.createElement('div');
        entry.innerHTML = `> ${msg}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const aspect = container.clientWidth / container.clientHeight;
        const d = 12;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(0, 5, 50);
        camera.lookAt(0, 5, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        generateBuilding();
        animate();
    }

    function clearScene() {
        if (buildingGroup) scene.remove(buildingGroup);
        buildingGroup = new THREE.Group();
        scene.add(buildingGroup);
        windowObjects = [];
    }

    function createBoxWithOutline(w, h, zPos = 0, color = 0xffffff, outlineColor = 0x999999, textureType = 'none') {
        const group = new THREE.Group();
        
        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            new THREE.MeshBasicMaterial({ color: color })
        );
        group.add(mesh);

        if (textureType !== 'none') {
            const patternMat = new THREE.LineBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.8 });
            if (textureType === 'siding') {
                for (let y = -h/2 + 0.3; y < h/2; y += 0.4) {
                    const pts = [new THREE.Vector3(-w/2, y, 0.005), new THREE.Vector3(w/2, y, 0.005)];
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), patternMat);
                    group.add(line);
                }
            } else if (textureType === 'blocks') {
                for (let y = -h/2 + 0.8; y < h/2; y += 0.8) {
                    const pts = [new THREE.Vector3(-w/2, y, 0.005), new THREE.Vector3(w/2, y, 0.005)];
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), patternMat);
                    group.add(line);
                }
                for (let x = -w/2 + 1; x < w/2; x += 1.5) {
                    const pts = [new THREE.Vector3(x, -h/2, 0.005), new THREE.Vector3(x, h/2, 0.005)];
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), patternMat);
                    group.add(line);
                }
            }
        }

        const edges = new THREE.EdgesGeometry(new THREE.PlaneGeometry(w, h));
        const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: outlineColor }));
        outline.position.z = 0.01;
        group.add(outline);

        group.position.z = zPos;
        return group;
    }

    function createWindow(x, y, w, h, type, details, zPos = 0.1) {
        let geo;
        if (type === 'circle') {
            geo = new THREE.CircleGeometry(w/2, 32);
        } else if (type === 'arch') {
            const shape = new THREE.Shape();
            shape.moveTo(-w/2, -h/2);
            shape.lineTo(w/2, -h/2);
            shape.lineTo(w/2, h/4);
            shape.absarc(0, h/4, w/2, 0, Math.PI, false);
            shape.lineTo(-w/2, -h/2);
            geo = new THREE.ShapeGeometry(shape);
        } else {
            geo = new THREE.PlaneGeometry(w, h);
        }

        const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
        mesh.position.set(x, y, zPos);
        buildingGroup.add(mesh);

        const outline = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x888888 }));
        outline.position.set(x, y, zPos + 0.01);
        buildingGroup.add(outline);

        if (details && type !== 'circle') {
            const gridMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
            const ptsH = [new THREE.Vector3(x - w/2, y, zPos + 0.02), new THREE.Vector3(x + w/2, y, zPos + 0.02)];
            const ptsV = [new THREE.Vector3(x, y - h/2, zPos + 0.02), new THREE.Vector3(x, y + h/2, zPos + 0.02)];
            buildingGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsH), gridMat));
            buildingGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(ptsV), gridMat));
        }

        windowObjects.push(mesh);
    }

    function generateBuilding() {
        clearScene();
        const mainW = 8 + Math.random() * 6;
        const floors = Math.floor(Math.random() * 4) + 1;
        const fH = 3.2;
        const texture = ['none', 'siding', 'blocks'][Math.floor(Math.random() * 3)];

        const mainBody = createBoxWithOutline(mainW, floors * fH, 0, 0xffffff, 0x666666, texture);
        mainBody.position.y = (floors * fH) / 2;
        buildingGroup.add(mainBody);

        const hasLeftWing = Math.random() > 0.4;
        const hasRightWing = Math.random() > 0.4;

        if (hasLeftWing) {
            const wingW = 4 + Math.random() * 3;
            const wingFloors = Math.max(1, floors - Math.floor(Math.random() * 2) - 1);
            const wing = createBoxWithOutline(wingW, wingFloors * fH, -0.1, 0xffffff, 0x666666, texture);
            wing.position.set(-mainW/2 - wingW/2, (wingFloors * fH) / 2, 0);
            buildingGroup.add(wing);
            addWindowsToSection(-mainW/2 - wingW/2, wingFloors, wingW, fH, true);
        }

        if (hasRightWing) {
            const isGarage = Math.random() > 0.5;
            const wingW = 5 + Math.random() * 2;
            const wingFloors = isGarage ? 1 : Math.max(1, floors - 1);
            const wing = createBoxWithOutline(wingW, wingFloors * fH, -0.1, 0xffffff, 0x666666, texture);
            wing.position.set(mainW/2 + wingW/2, (wingFloors * fH) / 2, 0);
            buildingGroup.add(wing);

            if (isGarage) {
                const gW = wingW * 0.7;
                const gH = 2.2;
                const gDoor = createBoxWithOutline(gW, gH, 0.1, 0xfafafa, 0x999999, 'siding');
                gDoor.position.set(mainW/2 + wingW/2, gH/2, 0);
                buildingGroup.add(gDoor);
            } else {
                addWindowsToSection(mainW/2 + wingW/2, wingFloors, wingW, fH, false);
            }
        }

        const roofType = ['flat', 'pitched', 'angled'][Math.floor(Math.random() * 3)];
        if (roofType !== 'flat') {
            const rH = 1.5 + Math.random() * 2.5;
            const roofShape = new THREE.Shape();
            if (roofType === 'pitched') {
                roofShape.moveTo(-mainW/2, 0);
                roofShape.lineTo(mainW/2, 0);
                roofShape.lineTo(0, rH);
            } else {
                roofShape.moveTo(-mainW/2, 0);
                roofShape.lineTo(mainW/2, 0);
                roofShape.lineTo(mainW/2, rH);
            }
            const roof = new THREE.Mesh(new THREE.ShapeGeometry(roofShape), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            roof.position.y = floors * fH;
            buildingGroup.add(roof);
            const rOutline = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.ShapeGeometry(roofShape)), new THREE.LineBasicMaterial({ color: 0x666666 }));
            rOutline.position.y = floors * fH;
            rOutline.position.z = 0.01;
            buildingGroup.add(rOutline);
        }

        addWindowsToSection(0, floors, mainW, fH, false, true);

        log(`Complex building sampled: ${floors} floors, ${texture} texture, ${roofType} roof.`);
    }

    function addWindowsToSection(centerX, floorCount, sectionW, floorH, forceAsym, hasMainDoor = false) {
        const winType = ['square', 'arch', 'circle', 'tall'][Math.floor(Math.random() * 4)];
        const useDetails = Math.random() > 0.4;
        const winScale = 0.5 + Math.random() * 0.4;
        const winW = (winType === 'tall' ? 0.6 : 1.2) * winScale;
        const winH = (winType === 'tall' ? 1.8 : 1.2) * winScale;

        const cols = Math.max(1, Math.floor(sectionW / 2.5));
        const spacing = sectionW / (cols + 1);

        for (let f = 0; f < floorCount; f++) {
            const y = (f * floorH) + (floorH / 2);
            const isGround = (f === 0);

            const skipProb = forceAsym ? 0.3 : 0.05;

            for (let c = 0; c < cols; c++) {
                if (Math.random() < skipProb) continue;

                const x = centerX - (sectionW/2) + (spacing * (c + 1));
                
                if (isGround && hasMainDoor && c === Math.floor(cols/2)) {
                    const dW = 1.2, dH = 2.2;
                    const door = createBoxWithOutline(dW, dH, 0.1, 0xffffff, 0x777777, 'none');
                    door.position.set(x, dH/2, 0);
                    buildingGroup.add(door);
                    const knob = new THREE.Mesh(new THREE.CircleGeometry(0.05, 8), new THREE.MeshBasicMaterial({color: 0x999999}));
                    knob.position.set(x + 0.4, dH/2, 0.15);
                    buildingGroup.add(knob);
                } else {
                    createWindow(x, y, winW, winH, winType, useDetails);
                }
            }
        }
    }

    function getBoundingBoxes() {
        const bboxes = [];
        windowObjects.forEach(obj => {
            const box = new THREE.Box3().setFromObject(obj);
            const min = box.min.clone().project(camera);
            const max = box.max.clone().project(camera);
            
            // Normalized 0-1000 coordinates
            const x1 = Math.round(((min.x + 1) / 2) * 1000);
            const x2 = Math.round(((max.x + 1) / 2) * 1000);
            const y1 = Math.round(((1 - max.y) / 2) * 1000); 
            const y2 = Math.round(((1 - min.y) / 2) * 1000);

            bboxes.push({
                "bbox_2d": [x1, y1, x2, y2],
                "label": "window"
            });
        });
        return bboxes;
    }

    function exportData() {
        renderer.render(scene, camera);
        const imgData = renderer.domElement.toDataURL("image/png");
        const bboxes = getBoundingBoxes();
        const jsonStr = JSON.stringify(bboxes, null, 4);

        const timestamp = new Date().getTime();
        downloadFile(imgData, `elevation_${timestamp}.png`);
        downloadFile("data:text/json;charset=utf-8," + encodeURIComponent(jsonStr), `metadata_${timestamp}.json`);
        
        log(`<span class="text-emerald-400">Exported ${bboxes.length} window annotations.</span>`);
    }

    function downloadFile(dataUrl, filename) {
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    document.getElementById('btn-sample').addEventListener('click', generateBuilding);
    document.getElementById('btn-export').addEventListener('click', exportData);

    window.addEventListener('resize', () => {
        const aspect = container.clientWidth / container.clientHeight;
        const d = 12;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });

    init();
</script>

</body>
</html>